{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Util.ts","webpack:///./src/HumanSolver.ts","webpack:///./src/backtracker.ts","webpack:///./src/SudokuSolver.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Util","deepClone","obj","JSON","parse","stringify","popRand","array","length","Error","index","Math","floor","random","result","splice","initGrid","Array","fill","map","makeGridFromString","str","j","charAt","getUniverseFromGrid","grid","row","col","getUniverseFromEmptyGrid","MakeNewA19","getUniverseSize","universe","sum","reduce","acc","getSquareList","square","forEach","x","y","push","getXY","Util_1","HumanSolver","getLevel","removeRowDuplicate","list","set","indexOf","removeColDuplicate","transposed","getTransposed","removeSquareDuplicate","squareList","backtracker","config","solutions","solution","getSolutionStructure","iterationId","universeCopy","maxIteration","strategy","possibilities","getPossibilities","pop","setSolution","checkSolution","max","resetSolution","resetPossibilities","backtracker_1","HumanSolver_1","checkGrid","checkRow","checkCol","slice","concat","checkSquare","_a","SudokuSolver","from","generate","naiveCarve","total","g","i_1","checkOneSolution","console","log","getAllSolution","humanSolve","config2","__assign","size","newSize","carve","btcarve","carvedGrid_1","config_1","last","findIndex","e","message","SudokuSolver_1"],"mappings":"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","file":"sudoku-generator.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export class Util {\n\n    static deepClone(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    static popRand(array) {\n        if (array.length === 0) {\n            throw new Error('cannot pop from an empty array');\n        }\n        const index = Math.floor(Math.random() * array.length);\n        const result = array[index];\n        array.splice(index, 1);\n        return result;\n    }\n    /**\n     * Initialize a grid 9x9 with 0.\n     * \n     * @static\n     * @returns \n     * [[0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0],\n     *  [0,0,0,0,0,0,0,0,0]]\n     * \n     * @memberof Util\n     */\n    static initGrid() {\n        return new Array(9).fill(0).map(() => new Array(9).fill(0));\n    }\n\n    static makeGridFromString(str: string) {\n        return new Array(9).fill(0).map((r, i) => new Array(9).fill(0).map((c, j) => +str.charAt(i * 9 + j)));\n    }\n\n    static getUniverseFromGrid(grid) {\n        return grid.map(row => row.map(col => {\n            if (col === 0) {\n                return new Array(9).fill(0).map((n, i) => i + 1);\n            }\n            return [col];\n        }));\n    }\n\n    static getUniverseFromEmptyGrid() {\n        return new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19));\n    }\n\n    static MakeNewA19 = () => new Array(9).fill(0).map((n, i) => i + 1);\n\n    static getUniverseSize(universe) {\n        return Util.sum(universe.map(row => row.map(col => col.length)).map(row => Util.sum(row)));\n    }\n\n    static sum(array) {\n        return array.reduce((acc, n) => acc + n, 0);\n    }\n\n    static getSquareList(universe) {\n        const result = [];\n        for (let i = 0; i < 9; i++) {\n            const square = [];\n            const row = Math.floor(i / 3);\n            const col = i % 3;\n            [0, 1, 2].forEach(x => [0, 1, 2].forEach(y => square.push(universe[(row * 3) + x][(col * 3) + y])));\n            result.push(square);\n        }\n        return result;\n    }\n/**\n * Compute the x y coordonnates from the string index.\n * Example : string '189000637736891524542300891678253149324918756915000382891000473263784915457139268'\n *                n  13\n * outputs { x: 1, y: 4 }\n * \n * \n * @static\n * @param {any} n \n * @returns the coordonates\n * @memberof Util\n */\nstatic getXY(n) {\n        return {\n            x: Math.floor(n / 9),\n            y: n % 9\n        };\n    }\n}\n","import { Util } from \"./Util\";\n\n\nfunction getTransposed(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        for (let j = 0; j < 9; j++) {\n            row.push(universe[j][i]);\n        }\n        result.push(row);\n    }\n    return result;\n}\n/**\n * Human solver try to reduce the universe size by applying rule for removing possibilities.\n * The universe is a mutable object for performance purpose.\n * \n * @export\n * @class HumanSolver\n */\nexport class HumanSolver {\n\n    static getLevel(universe) {\n        return universe.map(r => r.map(c => c.length).reduce((acc, n) => acc + n, 0)).reduce((acc, n) => acc + n, 0);\n    }\n\n    static removeRowDuplicate(universe) {\n        universe.forEach(row => {\n            const list = row.reduce((acc, set) => {\n                if (set.length === 1) {\n                    acc.push(set[0]);\n                }\n                return acc;\n            }, []);\n            row.forEach(set => {\n                if (set.length > 1) {\n                    list.forEach(n => {\n                        const index = set.indexOf(n);\n                        if (index !== -1) {\n                            set.splice(index, 1);\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    static removeColDuplicate(universe) {\n        const transposed = getTransposed(universe);\n        HumanSolver.removeRowDuplicate(transposed);\n    }\n\n    static removeSquareDuplicate(universe) {\n        const squareList = Util.getSquareList(universe);\n        HumanSolver.removeRowDuplicate(squareList);\n    }\n}\n","export function backtracker(config) {\n    const solutions = [];\n    const solution = config.getSolutionStructure();\n\n    let iterationId = 0;\n\n    let i = 0;\n\n    let universe = config.universe;\n    let universeCopy = JSON.parse(JSON.stringify(config.universe));\n    while (true) {\n        iterationId++;\n        if (config.maxIteration > 0 && iterationId > config.maxIteration) {\n            throw new Error('maxIteration reached.');\n        }\n        if (i === -1) {\n            if (config.strategy === 'find-all') {\n                break;\n            }\n            throw new Error('it seems that the backtracking cannot find a solution.');\n        }\n\n        const possibilities = config.getPossibilities(universe, i);\n\n        if (possibilities.length === 0) {\n            config.resetSolution(solution, i);\n            config.resetPossibilities(possibilities, i, universeCopy);\n            i--;\n            continue;\n        }\n\n        let n = config.pop(possibilities);\n        config.setSolution(solution, i, n);\n\n        const status = config.checkSolution(solution, i);\n        if (status) {\n            i++;\n        } else {\n            continue;\n        }\n        if (i === config.length) {\n            if (config.strategy === 'find-first') {\n                break;\n            }\n            if (config.strategy === 'find-all') {\n                const s = JSON.parse(JSON.stringify(solution));\n                solutions.push(s);\n                if (solutions.length >= config.max) {\n                    break;\n                }\n                i--;\n                continue;\n            }\n\n        }\n    }\n    if (config.strategy === 'find-first') {\n        return solution;\n    }\n    if (config.strategy === 'find-all') {\n        return solutions;\n    }\n}","import { backtracker } from './backtracker';\nimport { HumanSolver } from './HumanSolver';\nimport { Util } from './Util';\n\n\n\nfunction checkGrid(grid, x, y) {\n    return checkRow(grid, x, y) && checkCol(grid, x, y) && checkSquare(grid, x, y);\n}\n\nfunction checkRow(grid, x, y) {\n    return grid[x].indexOf(grid[x][y]) === y;\n}\n\nfunction checkCol(grid, x, y) {\n    const column = grid.map(row => row[y]);\n    return column.indexOf(grid[x][y]) === x;\n}\n\nfunction checkSquare(grid, x, y) {\n    const n = grid[x][y];\n    const i = Math.floor(x / 3);\n    const j = Math.floor(y / 3);\n    const square = grid.slice(i * 3, i * 3 + 3).map(row => row.slice(j * 3, j * 3 + 3));\n    square[x % 3][y % 3] = 0;\n    const flat = square.reduce((acc, row) => acc.concat(row), []);\n    return flat.indexOf(n) === -1;\n}\n\nconst config = {\n    getSolutionStructure: Util.initGrid,\n    universe: new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19)),\n    getPossibilities: (universe, i) => {\n        const { x, y } = Util.getXY(i);\n        return universe[x][y];\n    },\n    resetPossibilities: (possibilities, i, universeCopy) => {\n        const { x, y } = Util.getXY(i);\n        const origPossibilities = universeCopy[x][y];\n        origPossibilities.forEach(n => possibilities.push(n));\n    },\n    resetSolution: (solution, i) => {\n        const { x, y } = Util.getXY(i);\n        solution[x][y] = 0;\n    },\n    setSolution: (solution, i, n) => {\n        const { x, y } = Util.getXY(i);\n        solution[x][y] = n;\n    },\n    checkSolution: (solution, i) => {\n        const { x, y } = Util.getXY(i);\n        return checkGrid(solution, x, y);\n    },\n    pop: (possibilities) => {\n        return Util.popRand(possibilities);\n        // return possibilities.shift();\n    },\n    strategy: 'find-first',\n    max: 2,\n    length: 81,\n};\n\nexport class SudokuSolver {\n\n    static from(str: string) {\n        return Util.makeGridFromString(str);\n    }\n\n    static generate() {\n        config.universe = Util.getUniverseFromEmptyGrid();\n        return backtracker(config);\n    }\n\n    static naiveCarve(grid, total) {\n        let g;\n        let i = 0;\n        while (true) {\n            g = JSON.parse(JSON.stringify(grid));\n            const array = new Array(81).fill(0).map((n, i) => ({ r: Math.floor(i / 9), c: i % 9 }));\n            for (let i = 0; i < total; i++) {\n                const { r, c } = Util.popRand(array);\n                g[r][c] = 0;\n            }\n            if (SudokuSolver.checkOneSolution(g)) {\n                break;\n            }\n            i++;\n        }\n        console.log('found in %d iterations', i);\n        return g;\n\n    }\n\n    static checkOneSolution(grid) {\n        return SudokuSolver.getAllSolution(grid).length === 1;\n    }\n\n    static getAllSolution(grid) {\n\n        let universe = Util.getUniverseFromGrid(grid);\n        universe = SudokuSolver.humanSolve(universe);\n        const config2 = {\n            ...config,\n            universe,\n            strategy: 'find-all',\n            max: 2,\n            length: 81,\n            // pop: (possibilities) => {\n            //     return possibilities.shift();\n            // },\n        };\n\n        return backtracker(config2);\n    }\n\n    static humanSolve(universe) {\n        // console.log('universe level before', HumanSolver.getLevel(universe));\n        let result = Util.deepClone(universe);\n        let size;\n        let newSize = Util.getUniverseSize(result);\n        do {\n            size = newSize;\n            HumanSolver.removeRowDuplicate(result);\n            HumanSolver.removeColDuplicate(result);\n            HumanSolver.removeSquareDuplicate(result);\n            newSize = Util.getUniverseSize(result);\n        } while (newSize < size);\n        // console.log('universe level after', HumanSolver.getLevel(universe));\n        return result;\n    }\n\n    static carve(grid, total) {\n        return SudokuSolver.btcarve(grid, total);\n    }\n\n    static btcarve(grid, total) {\n        while (true) {\n            try {\n\n                let carvedGrid;\n                // perform a backtracking on carve.\n                const universe = new Array(total).fill(0).map(() => new Array(81).fill(0).map((n, i) => ({ row: Math.floor(i / 9), col: i % 9 })));\n                const config = {\n                    getSolutionStructure: () => [],\n                    universe,\n                    getPossibilities: (universe, i) => {\n                        return universe[i];\n                    },\n                    resetPossibilities: (possibilities, i, universeCopy) => {\n                        const origPossibilities = universeCopy[i];\n                        origPossibilities.forEach(n => possibilities.push(n));\n                    },\n                    resetSolution: (solution, i) => {\n                        solution.pop();\n                    },\n                    setSolution: (solution, i, n) => {\n                        if (solution.length === i) {\n                            solution[i - 1] = n;\n                            return;\n                        }\n                        if (solution.length === i - 1) {\n                            solution.push(n);\n                            return;\n                        }\n                    },\n                    checkSolution: (solution, i) => {\n                        // check if the last item is not equals to an existing one.\n                        const last = solution[i - 1];\n                        if (solution.findIndex(p => p.row === last.row && p.col === last.col) !== i - 1) {\n                            return false;\n                        }\n\n                        carvedGrid = JSON.parse(JSON.stringify(grid));\n                        solution.forEach(p => {\n                            carvedGrid[p.row][p.col] = 0;\n                        });\n                        return SudokuSolver.checkOneSolution(carvedGrid);\n                    },\n                    pop: (possibilities) => {\n                        const result = Util.popRand(possibilities);\n                        return result;\n                    },\n                    strategy: 'find-first',\n                    maxIteration: 500,\n                    length: total,\n                };\n\n                let solution = backtracker(config);\n                carvedGrid = JSON.parse(JSON.stringify(grid));\n                solution.forEach(p => {\n                    carvedGrid[p.row][p.col] = 0;\n                });\n                if (!SudokuSolver.checkOneSolution(carvedGrid)) {\n                    throw new Error('I am buggy');\n                }\n                return carvedGrid;\n            } catch (e) {\n                console.log('e', e.message)\n            }\n\n        }\n\n    }\n\n\n}\n\n\n","export { SudokuSolver } from './SudokuSolver';\n"],"sourceRoot":""}