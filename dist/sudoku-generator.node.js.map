{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Util.ts","webpack:///./src/HumanSolver.ts","webpack:///./src/backtracker.ts","webpack:///./src/SudokuSolver.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Util","deepClone","obj","JSON","parse","stringify","makeGridFromString","str","Array","fill","map","j","charAt","getUniverseFromGrid","grid","row","col","getUniverseFromEmptyGrid","MakeNewA19","getUniverseSize","universe","sum","length","array","reduce","acc","getSquareList","result","square","Math","floor","forEach","x","y","push","Util_1","HumanSolver","getLevel","removeRowDuplicate","list","set","index","indexOf","splice","removeColDuplicate","transposed","getTransposed","removeSquareDuplicate","squareList","backtracker","config","solutions","solution","getSolutionStructure","iterationId","universeCopy","maxIteration","Error","strategy","possibilities","getPossibilities","pop","setSolution","checkSolution","max","resetSolution","resetPossibilities","backtracker_1","HumanSolver_1","popRand","random","getXY","checkGrid","checkRow","checkCol","slice","concat","checkSquare","_a","SudokuSolver","from","generate","naiveCarve","total","g","i_1","checkOneSolution","console","log","getAllSolution","humanSolve","config2","__assign","size","newSize","carve","btcarve","carvedGrid_1","config_1","last","findIndex","e","message","SudokuSolver_1"],"mappings":"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","file":"sudoku-generator.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export class Util {\n\n    static deepClone(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    static makeGridFromString(str: string) {\n        return new Array(9).fill(0).map((r, i) => new Array(9).fill(0).map((c, j) => +str.charAt(i * 9 + j)));\n    }\n\n    static getUniverseFromGrid(grid) {\n        return grid.map(row => row.map(col => {\n            if (col === 0) {\n                return new Array(9).fill(0).map((n, i) => i + 1);\n            }\n            return [col];\n        }));\n    }\n\n    static getUniverseFromEmptyGrid() {\n        return new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19));\n    }\n\n    static MakeNewA19 = () => new Array(9).fill(0).map((n, i) => i + 1);\n\n    static getUniverseSize(universe) {\n        return Util.sum(universe.map(row => row.map(col => col.length)).map(row => Util.sum(row)));\n    }\n\n    static sum(array) {\n        return array.reduce((acc, n) => acc + n, 0);\n    }\n\n    static getSquareList(universe) {\n        const result = [];\n        for (let i = 0; i < 9; i++) {\n            const square = [];\n            const row = Math.floor(i / 3);\n            const col = i % 3;\n            [0, 1, 2].forEach(x => [0, 1, 2].forEach(y => square.push(universe[(row * 3) + x][(col * 3) + y])));\n            result.push(square);\n        }\n        return result;\n    }\n}\n","import { Util } from \"./Util\";\n\n\nfunction getTransposed(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        for (let j = 0; j < 9; j++) {\n            row.push(universe[j][i]);\n        }\n        result.push(row);\n    }\n    return result;\n}\n\nexport class HumanSolver {\n\n    static getLevel(universe) {\n        return universe.map(r => r.map(c => c.length).reduce((acc, n) => acc + n, 0)).reduce((acc, n) => acc + n, 0);\n    }\n\n    static removeRowDuplicate(universe) {\n\n        universe.forEach(row => {\n            const list = row.reduce((acc, set) => {\n                if (set.length === 1) {\n                    acc.push(set[0]);\n                }\n                return acc;\n            }, []);\n            row.forEach(set => {\n                if (set.length > 1) {\n                    list.forEach(n => {\n                        const index = set.indexOf(n);\n                        if (index !== -1) {\n                            set.splice(index, 1);\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    static removeColDuplicate(universe) {\n        const transposed = getTransposed(universe);\n        HumanSolver.removeRowDuplicate(transposed);\n    }\n\n    static removeSquareDuplicate(universe) {\n        const squareList = Util.getSquareList(universe);\n        HumanSolver.removeRowDuplicate(squareList);\n    }\n}\n","export function backtracker(config) {\n    const solutions = [];\n    const solution = config.getSolutionStructure();\n\n    let iterationId = 0;\n\n    let i = 0;\n\n    let universe = config.universe;\n    let universeCopy = JSON.parse(JSON.stringify(config.universe));\n    while (true) {\n        iterationId++;\n        if (config.maxIteration > 0 && iterationId > config.maxIteration) {\n            throw new Error('maxIteration reached.');\n        }\n        if (i === -1) {\n            if (config.strategy === 'find-all') {\n                break;\n            }\n            throw new Error('it seems that the backtracking cannot find a solution.');\n        }\n\n        const possibilities = config.getPossibilities(universe, i);\n\n        if (possibilities.length === 0) {\n            config.resetSolution(solution, i);\n            config.resetPossibilities(possibilities, i, universeCopy);\n            i--;\n            continue;\n        }\n\n        let n = config.pop(possibilities);\n        config.setSolution(solution, i, n);\n\n        const status = config.checkSolution(solution, i);\n        if (status) {\n            i++;\n        } else {\n            continue;\n        }\n        if (i === config.length) {\n            if (config.strategy === 'find-first') {\n                break;\n            }\n            if (config.strategy === 'find-all') {\n                const s = JSON.parse(JSON.stringify(solution));\n                solutions.push(s);\n                if (solutions.length >= config.max) {\n                    break;\n                }\n                i--;\n                continue;\n            }\n\n        }\n    }\n    if (config.strategy === 'find-first') {\n        return solution;\n    }\n    if (config.strategy === 'find-all') {\n        return solutions;\n    }\n}","import { backtracker } from './backtracker';\nimport { HumanSolver } from './HumanSolver';\nimport { Util } from './Util';\n\nfunction popRand(array) {\n    if (array.length === 0) {\n        throw new Error('cannot pop from an empty array');\n    }\n    const index = Math.floor(Math.random() * array.length);\n    const result = array[index];\n    array.splice(index, 1);\n    return result;\n}\n\nfunction initGrid() {\n    return new Array(9).fill(0).map(() => new Array(9).fill(0));\n}\n\nfunction getXY(n) {\n    return {\n        x: Math.floor(n / 9),\n        y: n % 9\n    }\n}\n\nfunction checkGrid(grid, x, y) {\n    return checkRow(grid, x, y) && checkCol(grid, x, y) && checkSquare(grid, x, y);\n}\n\nfunction checkRow(grid, x, y) {\n    return grid[x].indexOf(grid[x][y]) === y;\n}\n\nfunction checkCol(grid, x, y) {\n    const column = grid.map(row => row[y]);\n    return column.indexOf(grid[x][y]) === x;\n}\n\nfunction checkSquare(grid, x, y) {\n    const n = grid[x][y];\n    const i = Math.floor(x / 3);\n    const j = Math.floor(y / 3);\n    const square = grid.slice(i * 3, i * 3 + 3).map(row => row.slice(j * 3, j * 3 + 3));\n    square[x % 3][y % 3] = 0;\n    const flat = square.reduce((acc, row) => acc.concat(row), []);\n    return flat.indexOf(n) === -1;\n}\n\nconst config = {\n    getSolutionStructure: initGrid,\n    universe: new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19)),\n    getPossibilities: (universe, i) => {\n        const { x, y } = getXY(i);\n        return universe[x][y];\n    },\n    resetPossibilities: (possibilities, i, universeCopy) => {\n        const { x, y } = getXY(i);\n        const origPossibilities = universeCopy[x][y];\n        origPossibilities.forEach(n => possibilities.push(n));\n    },\n    resetSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = 0;\n    },\n    setSolution: (solution, i, n) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = n;\n    },\n    checkSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        return checkGrid(solution, x, y);\n    },\n    pop: (possibilities) => {\n        return popRand(possibilities);\n        // return possibilities.shift();\n    },\n    strategy: 'find-first',\n    max: 2,\n    length: 81,\n};\n\nexport class SudokuSolver {\n\n    static from(str: string) {\n        return Util.makeGridFromString(str);\n    }\n\n    static generate() {\n        config.universe = Util.getUniverseFromEmptyGrid();\n        return backtracker(config);\n    }\n\n    static naiveCarve(grid, total) {\n        let g;\n        let i = 0;\n        while (true) {\n            g = JSON.parse(JSON.stringify(grid));\n            const array = new Array(81).fill(0).map((n, i) => ({ r: Math.floor(i / 9), c: i % 9 }));\n            for (let i = 0; i < total; i++) {\n                const { r, c } = popRand(array);\n                g[r][c] = 0;\n            }\n            if (SudokuSolver.checkOneSolution(g)) {\n                break;\n            }\n            i++;\n        }\n        console.log('found in %d iterations', i);\n        return g;\n\n    }\n\n    static checkOneSolution(grid) {\n        return SudokuSolver.getAllSolution(grid).length === 1;\n    }\n\n    static getAllSolution(grid) {\n\n        const universe = Util.getUniverseFromGrid(grid);\n        SudokuSolver.humanSolve(universe);\n        const config2 = {\n            ...config,\n            universe,\n            strategy: 'find-all',\n            max: 2,\n            length: 81,\n            // pop: (possibilities) => {\n            //     return possibilities.shift();\n            // },\n        };\n\n        return backtracker(config2);\n    }\n\n    static humanSolve(universe) {\n        // console.log('universe level before', HumanSolver.getLevel(universe));\n        let result = Util.deepClone(universe);\n        let size;\n        let newSize = Util.getUniverseSize(result);\n        do {\n            size = newSize;\n            HumanSolver.removeRowDuplicate(result);\n            HumanSolver.removeColDuplicate(result);\n            HumanSolver.removeSquareDuplicate(result);\n            newSize = Util.getUniverseSize(result);\n        } while (newSize < size);\n        // console.log('universe level after', HumanSolver.getLevel(universe));\n        return result;\n    }\n\n    static carve(grid, total) {\n        return SudokuSolver.btcarve(grid, total);\n    }\n\n    static btcarve(grid, total) {\n        while (true) {\n            try {\n\n                let carvedGrid;\n                // perform a backtracking on carve.\n                const universe = new Array(total).fill(0).map(() => new Array(81).fill(0).map((n, i) => ({ row: Math.floor(i / 9), col: i % 9 })));\n                const config = {\n                    getSolutionStructure: () => [],\n                    universe,\n                    getPossibilities: (universe, i) => {\n                        return universe[i];\n                    },\n                    resetPossibilities: (possibilities, i, universeCopy) => {\n                        const origPossibilities = universeCopy[i];\n                        origPossibilities.forEach(n => possibilities.push(n));\n                    },\n                    resetSolution: (solution, i) => {\n                        solution.pop();\n                    },\n                    setSolution: (solution, i, n) => {\n                        if (solution.length === i) {\n                            solution[i - 1] = n;\n                            return;\n                        }\n                        if (solution.length === i - 1) {\n                            solution.push(n);\n                            return;\n                        }\n                    },\n                    checkSolution: (solution, i) => {\n                        console.log('i', i);\n                        // check if the last item is not equals to an existing one.\n                        const last = solution[i - 1];\n                        if (solution.findIndex(p => p.row === last.row && p.col === last.col) !== i - 1) {\n                            return false;\n                        }\n\n                        carvedGrid = JSON.parse(JSON.stringify(grid));\n                        solution.forEach(p => {\n                            carvedGrid[p.row][p.col] = 0;\n                        });\n                        return SudokuSolver.checkOneSolution(carvedGrid);\n                    },\n                    pop: (possibilities) => {\n                        const result = popRand(possibilities);\n                        return result;\n                    },\n                    strategy: 'find-first',\n                    maxIteration: 500,\n                    length: total,\n                };\n\n                let solution = backtracker(config);\n                carvedGrid = JSON.parse(JSON.stringify(grid));\n                solution.forEach(p => {\n                    carvedGrid[p.row][p.col] = 0;\n                });\n                if (!SudokuSolver.checkOneSolution(carvedGrid)) {\n                    throw new Error('I am buggy');\n                }\n                return carvedGrid;\n            } catch (e) {\n                console.log('e', e.message)\n            }\n\n        }\n\n    }\n\n\n}\n\n\n","export { SudokuSolver } from './SudokuSolver';\n"],"sourceRoot":""}