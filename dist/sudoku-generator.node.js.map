{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/HumanSolver.ts","webpack:///./src/backtracker.ts","webpack:///./src/SudokuSolver.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","HumanSolver","getLevel","universe","map","length","reduce","acc","removeRowDuplicate","forEach","row","list","set","push","index","indexOf","splice","removeColDuplicate","transposed","result","j","getTransposed","removeSquareDuplicate","squareList","square","Math","floor","col","x","y","getSquareList","backtracker","config","solutions","solution","getSolutionStructure","iterationId","universeCopy","JSON","parse","stringify","maxIteration","Error","strategy","possibilities","getPossibilities","pop","setSolution","checkSolution","max","resetSolution","resetPossibilities","backtracker_1","HumanSolver_1","a19","Array","fill","popRand","array","random","getXY","checkGrid","grid","checkRow","checkCol","slice","concat","checkSquare","_a","SudokuSolver","generate","naiveCarve","total","g","i_1","checkOneSolution","console","log","humanSolve","config2","__assign","carve","btcarve","carvedGrid_1","config_1","last","findIndex","e","message","SudokuSolver_1"],"mappings":"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","file":"sudoku-generator.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","function getSquareList(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const square = [];\n        const row = Math.floor(i / 3);\n        const col = i % 3;\n        [0, 1, 2].forEach(x => [0, 1, 2].forEach(y => square.push(universe[row + x][col + y])));\n        result.push(square);\n    }\n    return result;\n}\n\nfunction getTransposed(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        for (let j = 0; j < 9; j++) {\n            row.push(universe[j][i]);\n        }\n        result.push(row);\n    }\n    return result;\n}\n\n\nexport class HumanSolver {\n\n    static getLevel(universe) {\n        return universe.map(r => r.map(c => c.length).reduce((acc, n) => acc + n, 0)).reduce((acc, n) => acc + n, 0);\n    }\n\n    static removeRowDuplicate(universe) {\n\n        universe.forEach(row => {\n            const list = row.reduce((acc, set) => {\n                if (set.length === 1) {\n                    acc.push(set[0]);\n                }\n                return acc;\n            }, []);\n            row.forEach(set => {\n                if (set.length > 1) {\n                    list.forEach(n => {\n                        const index = set.indexOf(n);\n                        if (index !== -1) {\n                            set.splice(index, 1);\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    static removeColDuplicate(universe) {\n        const transposed = getTransposed(universe);\n        HumanSolver.removeRowDuplicate(transposed);\n    }\n\n    static removeSquareDuplicate(universe) {\n        const squareList = getSquareList(universe);\n        HumanSolver.removeRowDuplicate(squareList);\n    }\n}\n","export function backtracker(config) {\n    const solutions = [];\n    const solution = config.getSolutionStructure();\n\n    let iterationId = 0;\n\n    let i = 0;\n\n    let universe = config.universe;\n    let universeCopy = JSON.parse(JSON.stringify(config.universe));\n    while (true) {\n        iterationId++;\n        if (config.maxIteration > 0 && iterationId > config.maxIteration) {\n            throw new Error('maxIteration reached.');\n        }\n        if (i === -1) {\n            if (config.strategy === 'find-all') {\n                break;\n            }\n            throw new Error('it seems that the backtracking cannot find a solution.');\n        }\n\n        const possibilities = config.getPossibilities(universe, i);\n\n        if (possibilities.length === 0) {\n            config.resetSolution(solution, i);\n            config.resetPossibilities(possibilities, i, universeCopy);\n            i--;\n            continue;\n        }\n\n        let n = config.pop(possibilities);\n        config.setSolution(solution, i, n);\n\n        const status = config.checkSolution(solution, i);\n        if (status) {\n            i++;\n        } else {\n            continue;\n        }\n        if (i === config.length) {\n            if (config.strategy === 'find-first') {\n                break;\n            }\n            if (config.strategy === 'find-all') {\n                const s = JSON.parse(JSON.stringify(solution));\n                solutions.push(s);\n                if (solutions.length >= config.max) {\n                    break;\n                }\n                i--;\n                continue;\n            }\n\n        }\n    }\n    if (config.strategy === 'find-first') {\n        return solution;\n    }\n    if (config.strategy === 'find-all') {\n        return solutions;\n    }\n}","import { backtracker } from './backtracker';\nimport { HumanSolver } from './HumanSolver';\n\nconst a19 = () => new Array(9).fill(0).map((n, i) => i + 1);\n\nfunction popRand(array) {\n    if (array.length === 0) {\n        throw new Error('cannot pop from an empty array');\n    }\n    const index = Math.floor(Math.random() * array.length);\n    const result = array[index];\n    array.splice(index, 1);\n    return result;\n}\n\nfunction initGrid() {\n    return new Array(9).fill(0).map(() => new Array(9).fill(0));\n}\n\nfunction getXY(n) {\n    return {\n        x: Math.floor(n / 9),\n        y: n % 9\n    }\n}\n\nfunction checkGrid(grid, x, y) {\n    return checkRow(grid, x, y) && checkCol(grid, x, y) && checkSquare(grid, x, y);\n}\n\nfunction checkRow(grid, x, y) {\n    return grid[x].indexOf(grid[x][y]) === y;\n}\n\nfunction checkCol(grid, x, y) {\n    const column = grid.map(row => row[y]);\n    return column.indexOf(grid[x][y]) === x;\n}\n\nfunction checkSquare(grid, x, y) {\n    const n = grid[x][y];\n    const i = Math.floor(x / 3);\n    const j = Math.floor(y / 3);\n    const square = grid.slice(i * 3, i * 3 + 3).map(row => row.slice(j * 3, j * 3 + 3));\n    square[x % 3][y % 3] = 0;\n    const flat = square.reduce((acc, row) => acc.concat(row), []);\n    return flat.indexOf(n) === -1;\n}\n\nconst config = {\n    getSolutionStructure: initGrid,\n    universe: new Array(9).fill(0).map(() => new Array(9).fill(0).map(a19)),\n    getPossibilities: (universe, i) => {\n        const { x, y } = getXY(i);\n        return universe[x][y];\n    },\n    resetPossibilities: (possibilities, i, universeCopy) => {\n        const { x, y } = getXY(i);\n        const origPossibilities = universeCopy[x][y];\n        origPossibilities.forEach(n => possibilities.push(n));\n    },\n    resetSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = 0;\n    },\n    setSolution: (solution, i, n) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = n;\n    },\n    checkSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        return checkGrid(solution, x, y);\n    },\n    pop: (possibilities) => {\n        return popRand(possibilities);\n        // return possibilities.shift();\n    },\n    strategy: 'find-first',\n    max: 2,\n    length: 81,\n};\n\nexport class SudokuSolver {\n\n    static generate() {\n        config.universe = new Array(9).fill(0).map(() => new Array(9).fill(0).map(a19));\n        return backtracker(config);\n    }\n\n    static naiveCarve(grid, total) {\n        let g;\n        let i = 0;\n        while (true) {\n            g = JSON.parse(JSON.stringify(grid));\n            const array = new Array(81).fill(0).map((n, i) => ({ r: Math.floor(i / 9), c: i % 9 }));\n            for (let i = 0; i < total; i++) {\n                const { r, c } = popRand(array);\n                g[r][c] = 0;\n            }\n            if (SudokuSolver.checkOneSolution(g)) {\n                break;\n            }\n            i++;\n        }\n        console.log('found in %d iterations', i);\n        return g;\n\n    }\n\n    static checkOneSolution(grid) {\n\n        const universe = grid.map(row => row.map(col => {\n            if (col === 0) {\n                return new Array(9).fill(0).map((n, i) => i + 1);\n            }\n            return [col];\n        }));\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        const config2 = {\n            ...config,\n            universe,\n            strategy: 'find-all',\n            max: 2,\n            length: 81,\n            // pop: (possibilities) => {\n            //     return possibilities.shift();\n            // },\n        };\n        const result = backtracker(config2).length === 1;\n        return result;\n    }\n\n    static humanSolve(universe) {\n        // console.log('universe level before', HumanSolver.getLevel(universe));\n        HumanSolver.removeRowDuplicate(universe);\n        HumanSolver.removeColDuplicate(universe);\n        HumanSolver.removeSquareDuplicate(universe);\n        // console.log('universe level after', HumanSolver.getLevel(universe));\n    }\n\n    static carve(grid, total) {\n        return SudokuSolver.btcarve(grid, total);\n    }\n\n    static btcarve(grid, total) {\n        while (true) {\n            try {\n\n                let carvedGrid;\n                // perform a backtracking on carve.\n                const universe = new Array(total).fill(0).map(() => new Array(81).fill(0).map((n, i) => ({ row: Math.floor(i / 9), col: i % 9 })));\n                const config = {\n                    getSolutionStructure: () => [],\n                    universe,\n                    getPossibilities: (universe, i) => {\n                        return universe[i];\n                    },\n                    resetPossibilities: (possibilities, i, universeCopy) => {\n                        const origPossibilities = universeCopy[i];\n                        origPossibilities.forEach(n => possibilities.push(n));\n                    },\n                    resetSolution: (solution, i) => {\n                        solution.pop();\n                    },\n                    setSolution: (solution, i, n) => {\n                        if (solution.length === i) {\n                            solution[i - 1] = n;\n                            return;\n                        }\n                        if (solution.length === i - 1) {\n                            solution.push(n);\n                            return;\n                        }\n                    },\n                    checkSolution: (solution, i) => {\n                        // check if the last item is not equals to an existing one.\n                        const last = solution[i - 1];\n                        if (solution.findIndex(p => p.row === last.row && p.col === last.col) !== i - 1) {\n                            return false;\n                        }\n\n                        carvedGrid = JSON.parse(JSON.stringify(grid));\n                        solution.forEach(p => {\n                            carvedGrid[p.row][p.col] = 0;\n                        });\n                        return SudokuSolver.checkOneSolution(carvedGrid);\n                    },\n                    pop: (possibilities) => {\n                        const result = popRand(possibilities);\n                        return result;\n                    },\n                    strategy: 'find-first',\n                    maxIteration: 500,\n                    length: total,\n                };\n\n                let solution = backtracker(config);\n                return carvedGrid;\n            } catch (e) {\n                console.log('e', e.message)\n            }\n\n        }\n\n    }\n\n\n}\n\n\n","export { SudokuSolver } from './SudokuSolver';\n"],"sourceRoot":""}