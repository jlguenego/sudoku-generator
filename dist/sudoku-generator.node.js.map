{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Util.ts","webpack:///./src/HumanSolver.ts","webpack:///./src/backtracker.ts","webpack:///./src/SudokuSolver.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Util","deepClone","obj","JSON","parse","stringify","popRand","array","length","Error","index","Math","floor","random","result","splice","makeGridFromString","str","Array","fill","map","j","charAt","getUniverseFromGrid","grid","row","col","getUniverseFromEmptyGrid","MakeNewA19","getUniverseSize","universe","sum","reduce","acc","getSquareList","square","forEach","x","y","push","Util_1","HumanSolver","getLevel","removeRowDuplicate","list","set","indexOf","removeColDuplicate","transposed","getTransposed","removeSquareDuplicate","squareList","backtracker","config","solutions","solution","getSolutionStructure","iterationId","universeCopy","maxIteration","strategy","possibilities","getPossibilities","pop","setSolution","checkSolution","max","resetSolution","resetPossibilities","backtracker_1","HumanSolver_1","getXY","checkGrid","checkRow","checkCol","slice","concat","checkSquare","_a","SudokuSolver","from","generate","naiveCarve","total","g","i_1","checkOneSolution","console","log","getAllSolution","humanSolve","config2","__assign","size","newSize","carve","btcarve","carvedGrid_1","config_1","last","findIndex","e","message","SudokuSolver_1"],"mappings":"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","file":"sudoku-generator.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export class Util {\n\n    static deepClone(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n\n    static popRand(array) {\n        if (array.length === 0) {\n            throw new Error('cannot pop from an empty array');\n        }\n        const index = Math.floor(Math.random() * array.length);\n        const result = array[index];\n        array.splice(index, 1);\n        return result;\n    }\n\n    static makeGridFromString(str: string) {\n        return new Array(9).fill(0).map((r, i) => new Array(9).fill(0).map((c, j) => +str.charAt(i * 9 + j)));\n    }\n\n    static getUniverseFromGrid(grid) {\n        return grid.map(row => row.map(col => {\n            if (col === 0) {\n                return new Array(9).fill(0).map((n, i) => i + 1);\n            }\n            return [col];\n        }));\n    }\n\n    static getUniverseFromEmptyGrid() {\n        return new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19));\n    }\n\n    static MakeNewA19 = () => new Array(9).fill(0).map((n, i) => i + 1);\n\n    static getUniverseSize(universe) {\n        return Util.sum(universe.map(row => row.map(col => col.length)).map(row => Util.sum(row)));\n    }\n\n    static sum(array) {\n        return array.reduce((acc, n) => acc + n, 0);\n    }\n\n    static getSquareList(universe) {\n        const result = [];\n        for (let i = 0; i < 9; i++) {\n            const square = [];\n            const row = Math.floor(i / 3);\n            const col = i % 3;\n            [0, 1, 2].forEach(x => [0, 1, 2].forEach(y => square.push(universe[(row * 3) + x][(col * 3) + y])));\n            result.push(square);\n        }\n        return result;\n    }\n}\n","import { Util } from \"./Util\";\n\n\nfunction getTransposed(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        for (let j = 0; j < 9; j++) {\n            row.push(universe[j][i]);\n        }\n        result.push(row);\n    }\n    return result;\n}\n/**\n * Human solver try to reduce the universe size by applying rule for removing possibilities.\n * The universe is a mutable object for performance purpose.\n * \n * @export\n * @class HumanSolver\n */\nexport class HumanSolver {\n\n    static getLevel(universe) {\n        return universe.map(r => r.map(c => c.length).reduce((acc, n) => acc + n, 0)).reduce((acc, n) => acc + n, 0);\n    }\n\n    static removeRowDuplicate(universe) {\n        universe.forEach(row => {\n            const list = row.reduce((acc, set) => {\n                if (set.length === 1) {\n                    acc.push(set[0]);\n                }\n                return acc;\n            }, []);\n            row.forEach(set => {\n                if (set.length > 1) {\n                    list.forEach(n => {\n                        const index = set.indexOf(n);\n                        if (index !== -1) {\n                            set.splice(index, 1);\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    static removeColDuplicate(universe) {\n        const transposed = getTransposed(universe);\n        HumanSolver.removeRowDuplicate(transposed);\n    }\n\n    static removeSquareDuplicate(universe) {\n        const squareList = Util.getSquareList(universe);\n        HumanSolver.removeRowDuplicate(squareList);\n    }\n}\n","export function backtracker(config) {\n    const solutions = [];\n    const solution = config.getSolutionStructure();\n\n    let iterationId = 0;\n\n    let i = 0;\n\n    let universe = config.universe;\n    let universeCopy = JSON.parse(JSON.stringify(config.universe));\n    while (true) {\n        iterationId++;\n        if (config.maxIteration > 0 && iterationId > config.maxIteration) {\n            throw new Error('maxIteration reached.');\n        }\n        if (i === -1) {\n            if (config.strategy === 'find-all') {\n                break;\n            }\n            throw new Error('it seems that the backtracking cannot find a solution.');\n        }\n\n        const possibilities = config.getPossibilities(universe, i);\n\n        if (possibilities.length === 0) {\n            config.resetSolution(solution, i);\n            config.resetPossibilities(possibilities, i, universeCopy);\n            i--;\n            continue;\n        }\n\n        let n = config.pop(possibilities);\n        config.setSolution(solution, i, n);\n\n        const status = config.checkSolution(solution, i);\n        if (status) {\n            i++;\n        } else {\n            continue;\n        }\n        if (i === config.length) {\n            if (config.strategy === 'find-first') {\n                break;\n            }\n            if (config.strategy === 'find-all') {\n                const s = JSON.parse(JSON.stringify(solution));\n                solutions.push(s);\n                if (solutions.length >= config.max) {\n                    break;\n                }\n                i--;\n                continue;\n            }\n\n        }\n    }\n    if (config.strategy === 'find-first') {\n        return solution;\n    }\n    if (config.strategy === 'find-all') {\n        return solutions;\n    }\n}","import { backtracker } from './backtracker';\nimport { HumanSolver } from './HumanSolver';\nimport { Util } from './Util';\n\nfunction initGrid() {\n    return new Array(9).fill(0).map(() => new Array(9).fill(0));\n}\n\nfunction getXY(n) {\n    return {\n        x: Math.floor(n / 9),\n        y: n % 9\n    }\n}\n\nfunction checkGrid(grid, x, y) {\n    return checkRow(grid, x, y) && checkCol(grid, x, y) && checkSquare(grid, x, y);\n}\n\nfunction checkRow(grid, x, y) {\n    return grid[x].indexOf(grid[x][y]) === y;\n}\n\nfunction checkCol(grid, x, y) {\n    const column = grid.map(row => row[y]);\n    return column.indexOf(grid[x][y]) === x;\n}\n\nfunction checkSquare(grid, x, y) {\n    const n = grid[x][y];\n    const i = Math.floor(x / 3);\n    const j = Math.floor(y / 3);\n    const square = grid.slice(i * 3, i * 3 + 3).map(row => row.slice(j * 3, j * 3 + 3));\n    square[x % 3][y % 3] = 0;\n    const flat = square.reduce((acc, row) => acc.concat(row), []);\n    return flat.indexOf(n) === -1;\n}\n\nconst config = {\n    getSolutionStructure: initGrid,\n    universe: new Array(9).fill(0).map(() => new Array(9).fill(0).map(Util.MakeNewA19)),\n    getPossibilities: (universe, i) => {\n        const { x, y } = getXY(i);\n        return universe[x][y];\n    },\n    resetPossibilities: (possibilities, i, universeCopy) => {\n        const { x, y } = getXY(i);\n        const origPossibilities = universeCopy[x][y];\n        origPossibilities.forEach(n => possibilities.push(n));\n    },\n    resetSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = 0;\n    },\n    setSolution: (solution, i, n) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = n;\n    },\n    checkSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        return checkGrid(solution, x, y);\n    },\n    pop: (possibilities) => {\n        return Util.popRand(possibilities);\n        // return possibilities.shift();\n    },\n    strategy: 'find-first',\n    max: 2,\n    length: 81,\n};\n\nexport class SudokuSolver {\n\n    static from(str: string) {\n        return Util.makeGridFromString(str);\n    }\n\n    static generate() {\n        config.universe = Util.getUniverseFromEmptyGrid();\n        return backtracker(config);\n    }\n\n    static naiveCarve(grid, total) {\n        let g;\n        let i = 0;\n        while (true) {\n            g = JSON.parse(JSON.stringify(grid));\n            const array = new Array(81).fill(0).map((n, i) => ({ r: Math.floor(i / 9), c: i % 9 }));\n            for (let i = 0; i < total; i++) {\n                const { r, c } = Util.popRand(array);\n                g[r][c] = 0;\n            }\n            if (SudokuSolver.checkOneSolution(g)) {\n                break;\n            }\n            i++;\n        }\n        console.log('found in %d iterations', i);\n        return g;\n\n    }\n\n    static checkOneSolution(grid) {\n        return SudokuSolver.getAllSolution(grid).length === 1;\n    }\n\n    static getAllSolution(grid) {\n\n        let universe = Util.getUniverseFromGrid(grid);\n        universe = SudokuSolver.humanSolve(universe);\n        const config2 = {\n            ...config,\n            universe,\n            strategy: 'find-all',\n            max: 2,\n            length: 81,\n            // pop: (possibilities) => {\n            //     return possibilities.shift();\n            // },\n        };\n\n        return backtracker(config2);\n    }\n\n    static humanSolve(universe) {\n        // console.log('universe level before', HumanSolver.getLevel(universe));\n        let result = Util.deepClone(universe);\n        let size;\n        let newSize = Util.getUniverseSize(result);\n        do {\n            size = newSize;\n            HumanSolver.removeRowDuplicate(result);\n            HumanSolver.removeColDuplicate(result);\n            HumanSolver.removeSquareDuplicate(result);\n            newSize = Util.getUniverseSize(result);\n        } while (newSize < size);\n        // console.log('universe level after', HumanSolver.getLevel(universe));\n        return result;\n    }\n\n    static carve(grid, total) {\n        return SudokuSolver.btcarve(grid, total);\n    }\n\n    static btcarve(grid, total) {\n        while (true) {\n            try {\n\n                let carvedGrid;\n                // perform a backtracking on carve.\n                const universe = new Array(total).fill(0).map(() => new Array(81).fill(0).map((n, i) => ({ row: Math.floor(i / 9), col: i % 9 })));\n                const config = {\n                    getSolutionStructure: () => [],\n                    universe,\n                    getPossibilities: (universe, i) => {\n                        return universe[i];\n                    },\n                    resetPossibilities: (possibilities, i, universeCopy) => {\n                        const origPossibilities = universeCopy[i];\n                        origPossibilities.forEach(n => possibilities.push(n));\n                    },\n                    resetSolution: (solution, i) => {\n                        solution.pop();\n                    },\n                    setSolution: (solution, i, n) => {\n                        if (solution.length === i) {\n                            solution[i - 1] = n;\n                            return;\n                        }\n                        if (solution.length === i - 1) {\n                            solution.push(n);\n                            return;\n                        }\n                    },\n                    checkSolution: (solution, i) => {\n                        // check if the last item is not equals to an existing one.\n                        const last = solution[i - 1];\n                        if (solution.findIndex(p => p.row === last.row && p.col === last.col) !== i - 1) {\n                            return false;\n                        }\n\n                        carvedGrid = JSON.parse(JSON.stringify(grid));\n                        solution.forEach(p => {\n                            carvedGrid[p.row][p.col] = 0;\n                        });\n                        return SudokuSolver.checkOneSolution(carvedGrid);\n                    },\n                    pop: (possibilities) => {\n                        const result = Util.popRand(possibilities);\n                        return result;\n                    },\n                    strategy: 'find-first',\n                    maxIteration: 500,\n                    length: total,\n                };\n\n                let solution = backtracker(config);\n                carvedGrid = JSON.parse(JSON.stringify(grid));\n                solution.forEach(p => {\n                    carvedGrid[p.row][p.col] = 0;\n                });\n                if (!SudokuSolver.checkOneSolution(carvedGrid)) {\n                    throw new Error('I am buggy');\n                }\n                return carvedGrid;\n            } catch (e) {\n                console.log('e', e.message)\n            }\n\n        }\n\n    }\n\n\n}\n\n\n","export { SudokuSolver } from './SudokuSolver';\n"],"sourceRoot":""}