{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/backtracker.ts","webpack:///./src/HumanSolver.ts","webpack:///./src/SudokuSolver.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","backtracker","config","solutions","solution","getSolutionStructure","iterationId","universe","universeCopy","JSON","parse","stringify","maxIteration","Error","strategy","possibilities","getPossibilities","length","resetSolution","resetPossibilities","pop","setSolution","checkSolution","push","max","HumanSolver","[object Object]","map","reduce","acc","forEach","row","list","set","index","indexOf","splice","transposed","result","j","getTransposed","removeRowDuplicate","squareList","square","Math","floor","col","x","y","getSquareList","a19","Array","fill","popRand","array","random","getXY","checkGrid","grid","checkRow","checkCol","slice","concat","checkSquare","SudokuSolver_config","SudokuSolver_SudokuSolver","total","g","checkOneSolution","console","log","humanSolve","removeColDuplicate","removeSquareDuplicate","btcarve","carvedGrid","last","findIndex","e","message"],"mappings":"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","file":"sudoku-generator.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export function backtracker(config) {\n    const solutions = [];\n    const solution = config.getSolutionStructure();\n\n    let iterationId = 0;\n\n    let i = 0;\n\n    let universe = config.universe;\n    let universeCopy = JSON.parse(JSON.stringify(config.universe));\n    while (true) {\n        iterationId++;\n        if (config.maxIteration > 0 && iterationId > config.maxIteration) {\n            throw new Error('maxIteration reached.');\n        }\n        if (i === -1) {\n            if (config.strategy === 'find-all') {\n                break;\n            }\n            throw new Error('it seems that the backtracking cannot find a solution.');\n        }\n\n        const possibilities = config.getPossibilities(universe, i);\n\n        if (possibilities.length === 0) {\n            config.resetSolution(solution, i);\n            config.resetPossibilities(possibilities, i, universeCopy);\n            i--;\n            continue;\n        }\n\n        let n = config.pop(possibilities);\n        config.setSolution(solution, i, n);\n\n        const status = config.checkSolution(solution, i);\n        if (status) {\n            i++;\n        } else {\n            continue;\n        }\n        if (i === config.length) {\n            if (config.strategy === 'find-first') {\n                break;\n            }\n            if (config.strategy === 'find-all') {\n                const s = JSON.parse(JSON.stringify(solution));\n                solutions.push(s);\n                if (solutions.length >= config.max) {\n                    break;\n                }\n                i--;\n                continue;\n            }\n\n        }\n    }\n    if (config.strategy === 'find-first') {\n        return solution;\n    }\n    if (config.strategy === 'find-all') {\n        return solutions;\n    }\n}","function getSquareList(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const square = [];\n        const row = Math.floor(i / 3);\n        const col = i % 3;\n        [0, 1, 2].forEach(x => [0, 1, 2].forEach(y => square.push(universe[row + x][col + y])));\n        result.push(square);\n    }\n    return result;\n}\n\nfunction getTransposed(universe) {\n    const result = [];\n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        for (let j = 0; j < 9; j++) {\n            row.push(universe[j][i]);\n        }\n        result.push(row);\n    }\n    return result;\n}\n\n\nexport class HumanSolver {\n\n    static getLevel(universe) {\n        return universe.map(r => r.map(c => c.length).reduce((acc, n) => acc + n, 0)).reduce((acc, n) => acc + n, 0);\n    }\n\n    static removeRowDuplicate(universe) {\n\n        universe.forEach(row => {\n            const list = row.reduce((acc, set) => {\n                if (set.length === 1) {\n                    acc.push(set[0]);\n                }\n                return acc;\n            }, []);\n            row.forEach(set => {\n                if (set.length > 1) {\n                    list.forEach(n => {\n                        const index = set.indexOf(n);\n                        if (index !== -1) {\n                            set.splice(index, 1);\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    static removeColDuplicate(universe) {\n        const transposed = getTransposed(universe);\n        HumanSolver.removeRowDuplicate(transposed);\n    }\n\n    static removeSquareDuplicate(universe) {\n        const squareList = getSquareList(universe);\n        HumanSolver.removeRowDuplicate(squareList);\n    }\n}\n","import { backtracker } from './backtracker';\nimport { HumanSolver } from './HumanSolver';\n\nconst a19 = () => new Array(9).fill(0).map((n, i) => i + 1);\n\nfunction popRand(array) {\n    if (array.length === 0) {\n        throw new Error('cannot pop from an empty array');\n    }\n    const index = Math.floor(Math.random() * array.length);\n    const result = array[index];\n    array.splice(index, 1);\n    return result;\n}\n\nfunction initGrid() {\n    return new Array(9).fill(0).map(() => new Array(9).fill(0));\n}\n\nfunction getXY(n) {\n    return {\n        x: Math.floor(n / 9),\n        y: n % 9\n    }\n}\n\nfunction checkGrid(grid, x, y) {\n    return checkRow(grid, x, y) && checkCol(grid, x, y) && checkSquare(grid, x, y);\n}\n\nfunction checkRow(grid, x, y) {\n    return grid[x].indexOf(grid[x][y]) === y;\n}\n\nfunction checkCol(grid, x, y) {\n    const column = grid.map(row => row[y]);\n    return column.indexOf(grid[x][y]) === x;\n}\n\nfunction checkSquare(grid, x, y) {\n    const n = grid[x][y];\n    const i = Math.floor(x / 3);\n    const j = Math.floor(y / 3);\n    const square = grid.slice(i * 3, i * 3 + 3).map(row => row.slice(j * 3, j * 3 + 3));\n    square[x % 3][y % 3] = 0;\n    const flat = square.reduce((acc, row) => acc.concat(row), []);\n    return flat.indexOf(n) === -1;\n}\n\nconst config = {\n    getSolutionStructure: initGrid,\n    universe: new Array(9).fill(0).map(() => new Array(9).fill(0).map(a19)),\n    getPossibilities: (universe, i) => {\n        const { x, y } = getXY(i);\n        return universe[x][y];\n    },\n    resetPossibilities: (possibilities, i, universeCopy) => {\n        const { x, y } = getXY(i);\n        const origPossibilities = universeCopy[x][y];\n        origPossibilities.forEach(n => possibilities.push(n));\n    },\n    resetSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = 0;\n    },\n    setSolution: (solution, i, n) => {\n        const { x, y } = getXY(i);\n        solution[x][y] = n;\n    },\n    checkSolution: (solution, i) => {\n        const { x, y } = getXY(i);\n        return checkGrid(solution, x, y);\n    },\n    pop: (possibilities) => {\n        return popRand(possibilities);\n        // return possibilities.shift();\n    },\n    strategy: 'find-first',\n    max: 2,\n    length: 81,\n};\n\nexport class SudokuSolver {\n\n    static generate() {\n        config.universe = new Array(9).fill(0).map(() => new Array(9).fill(0).map(a19));\n        return backtracker(config);\n    }\n\n    static naiveCarve(grid, total) {\n        let g;\n        let i = 0;\n        while (true) {\n            g = JSON.parse(JSON.stringify(grid));\n            const array = new Array(81).fill(0).map((n, i) => ({ r: Math.floor(i / 9), c: i % 9 }));\n            for (let i = 0; i < total; i++) {\n                const { r, c } = popRand(array);\n                g[r][c] = 0;\n            }\n            if (SudokuSolver.checkOneSolution(g)) {\n                break;\n            }\n            i++;\n        }\n        console.log('found in %d iterations', i);\n        return g;\n\n    }\n\n    static checkOneSolution(grid) {\n\n        const universe = grid.map(row => row.map(col => {\n            if (col === 0) {\n                return new Array(9).fill(0).map((n, i) => i + 1);\n            }\n            return [col];\n        }));\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        SudokuSolver.humanSolve(universe);\n        const config2 = {\n            ...config,\n            universe,\n            strategy: 'find-all',\n            max: 2,\n            length: 81,\n            // pop: (possibilities) => {\n            //     return possibilities.shift();\n            // },\n        };\n        const result = backtracker(config2).length === 1;\n        return result;\n    }\n\n    static humanSolve(universe) {\n        // console.log('universe level before', HumanSolver.getLevel(universe));\n        HumanSolver.removeRowDuplicate(universe);\n        HumanSolver.removeColDuplicate(universe);\n        HumanSolver.removeSquareDuplicate(universe);\n        // console.log('universe level after', HumanSolver.getLevel(universe));\n    }\n\n    static carve(grid, total) {\n        return SudokuSolver.btcarve(grid, total);\n    }\n\n    static btcarve(grid, total) {\n        while (true) {\n            try {\n\n                let carvedGrid;\n                // perform a backtracking on carve.\n                const universe = new Array(total).fill(0).map(() => new Array(81).fill(0).map((n, i) => ({ row: Math.floor(i / 9), col: i % 9 })));\n                const config = {\n                    getSolutionStructure: () => [],\n                    universe,\n                    getPossibilities: (universe, i) => {\n                        return universe[i];\n                    },\n                    resetPossibilities: (possibilities, i, universeCopy) => {\n                        const origPossibilities = universeCopy[i];\n                        origPossibilities.forEach(n => possibilities.push(n));\n                    },\n                    resetSolution: (solution, i) => {\n                        solution.pop();\n                    },\n                    setSolution: (solution, i, n) => {\n                        if (solution.length === i) {\n                            solution[i - 1] = n;\n                            return;\n                        }\n                        if (solution.length === i - 1) {\n                            solution.push(n);\n                            return;\n                        }\n                    },\n                    checkSolution: (solution, i) => {\n                        // check if the last item is not equals to an existing one.\n                        const last = solution[i - 1];\n                        if (solution.findIndex(p => p.row === last.row && p.col === last.col) !== i - 1) {\n                            return false;\n                        }\n\n                        carvedGrid = JSON.parse(JSON.stringify(grid));\n                        solution.forEach(p => {\n                            carvedGrid[p.row][p.col] = 0;\n                        });\n                        return SudokuSolver.checkOneSolution(carvedGrid);\n                    },\n                    pop: (possibilities) => {\n                        const result = popRand(possibilities);\n                        return result;\n                    },\n                    strategy: 'find-first',\n                    maxIteration: 500,\n                    length: total,\n                };\n\n                let solution = backtracker(config);\n                return carvedGrid;\n            } catch (e) {\n                console.log('e', e.message)\n            }\n\n        }\n\n    }\n\n\n}\n\n\n"],"sourceRoot":""}